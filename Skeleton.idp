LTCvocabulary Arkham { 
    // DO NOT CHANGE
    type Time isa nat
    Start : Time
    partial Next(Time) : Time
    
    type number isa nat

    type location
    type district isa location
    type building isa location

    Move_To(Time, location)
    Close_Gate(Time)
    Attack(Time)

    Location(Time) : location
    I_Location : location

    type monsternb = {0..3} isa nat
    Monsters_In(Time, location) : monsternb
    Exit_Gate(Time, building)

    Clues(Time) : number

    Open_Gate(Time, building)
    C_Open_Gate(Time, building)
    Closed_Gate(Time, building)


    Has_Connection(location, location)


    type state constructed from {player_turn, monster_turn, won, lost}
    GameState(Time) : state
    Closed_To_Win : number
    Open_To_Lose : number

    //Add your own predicates here
    
    // At Time, monsternb monsters will move from location to district
    Monster_Move(Time, location, district) : monsternb
    
    // Causes to win or lose
    C_Win(Time)
    C_Lose(Time)
}


theory T : Arkham {
    // INVESTIGATOR MOVES AND ATTACKS
    Location(Start) = I_Location .
    {
        // Every player turn the investigator moves from a location to an adjacent location l where there are less than 3 monsters
        ! t [Time] l [location] :  Location(t) = l <- Move_To(t,l) .    
    }
    ! t [Time] l [location] : Move_To(Next(t),l) => Has_Connection(Location(t),l) & Monsters_In(Next(t),l) < 3 & GameState(Next(t)) = player_turn .

    // If the investigator attacks, all monsters in the location die
    ! t [Time] : Attack(t) => ? l [location] : Location(t) = l & Monsters_In(t,l) = 0 .
    // If the investigator attacks, he gains clues in t+1 equal to the monsters killed capped at 10
    /*
    {
        ! t [Time] : Clues(Next(t)) = 10 <- ? l [location] : Attack(t) & Clues(t) + Monsters_In(t-1,l) > 10 & Location(t) = l .
        ! t [Time] l [location] : Clues(Next(t)) = Clues(t) + Monsters_In(t-1,l) <- Attack(t) & Clues(t) + Monsters_In(t-1,l) > 10 & Location(t) = l .
        ! t [Time] : Clues(Next(t)) = Clues(t) <- ~Attack(t) .       
    }
	*/   	
    ! t [Time] : Clues(t) =< 10 .
    Clues(Start) = 0 .
    
    // GATE STUFF
    {
        // An investigator can cause a gate to close if present in a location with an open gate and at least 2 clues
        ! t [Time] : Close_Gate(t) <- ? b [building] : Location(t) = b & Open_Gate(t,b) & Clues(t) >= 2.
    }
    // If the investigator closes a gate, he will lose 2 clues
    ! t [Time] : Close_Gate(t) => Clues(Next(t)) = Clues(t) - 2 .
    // If there is cause for a gate to open at time t, it will open at time t
    ! t [Time] b [building] : C_Open_Gate(t,b) => Open_Gate(Next(t),b) & ~Closed_Gate(Next(t),b).
    
    
    // An investigator can only do one action per turn
    ! t [Time] : GameState(t) = player_turn => Attack(t) | Close_Gate(t) | ~(Attack(t) & Close_Gate(t)) .
    
    
    // MONSTER STUFF
    {
        // Every monster turn every monster moves from a location l to an adjacent district d where there are less than 3 monsters
        ! t [Time] l [location] : Monsters_In(t,l) = sum{ d [district], amount [monsternb] : Monster_Move(t,l,d) = amount & Has_Connection(l,d) : amount} <- .
        ! t [Time] d [district] : Monsters_In(t,d) = sum{ l [location], amount [monsternb] : Monster_Move(t,l,d) = amount & Has_Connection(l,d) : amount } <- .
        
        // Every monster turn, one monster comes out of every open gate
        ! t [Time] b [building] : Exit_Gate(t,b) <- Open_Gate(t,b) & GameState(t) = monster_turn.
    }
    // If a monster exits a gate at time t, it will be in that building at time t
    ! t [Time] b [building] : Exit_Gate(t,b) => Monsters_In(t,b) = 1.
    
    
    // WIN/LOSE CONDITIONS
    {
        // Win is caused by the amount of closed gates at t + 1 being higher or equal to the amount required
        ! t [Time] : C_Win(t) <- #{ b [building] : Closed_Gate(t, b)} + #{ : Close_Gate(t) } >= Closed_To_Win .
        // Lose is caused by the amount of open gates at t + 1 being higher or equal to the amount required
        ! t [Time] : C_Lose(t) <- #{ b [building] : Open_Gate(t, b)} + #{ b [building] : C_Open_Gate(t, b) } >= Open_To_Lose .
        // Lose is caused by not being able to move at player_turn
        ! t [Time] : C_Lose(t) <- GameState(t) = monster_turn & ? l : Location(t) = l & (! l2 : Has_Connection(l,l2) => Monsters_In(t,l2) >= 3).
    }
    
    // STATE CHANGES
    GameState(Start) = player_turn.
    {
        // If the game is won, it stays that way.
        ! t [Time] : GameState(Next(t)) = won <- GameState(t) = won | C_Win(t).
        // If the game is lost, it stays that way.
        ! t [Time] : GameState(Next(t)) = lost <- GameState(t) = lost | C_Lose(t).
        // If current turn is monster turn and not won or lost, next turn is player turn.
    	! t [Time] : GameState(Next(t)) = player_turn <- GameState(t) = monster_turn & ~ C_Win(t) & ~ C_Lose(t).
        // If current turn is player turn and not won or lost, next turn is monster turn.
    	! t [Time] : GameState(Next(t)) = monster_turn <- GameState(t) = player_turn & ~ C_Win(t) & ~ C_Lose(t).
        // If there is a cause to win in current turn, next turn is won.
        //! t [Time] : GameState(Next(t)) = won <- C_Win(t).
        // If there is a cause to lose in current turn, next turn is lost.
        //! t [Time] : GameState(Next(t)) = lost <- C_Lose(t).
    }
    
}

theory TimeTheo : Arkham{
    { 
        Start = MIN[:Time].
        !t : Next(t) = t + 1 <- Time(t+1). 
    }
}

procedure main() {
    show(Easy)
}


//Use this to visualise structure struc
procedure show(struc) {
    idpd3.init_idpd3();
    stdoptions.nbmodels = 1
	TH = clone(struc);
    setvocabulary(TH, Arkham);
    S = calculatedefinitions(merge(TimeTheo, T), TH)
    //S = propagate(T,S)

    local model = modelexpand(T, S)[1];
    setvocabulary(model, V_out);
    local vis = merge(model, struc);
    local visModel = modelexpand(T_out, vis)[1];
	print(visModel)
    idpd3.visualise(visModel);
}


/************************************************
 *  Fill in the next part for the verifications *
 ************************************************/

theory verification1: Arkham{
	//Verify something here
}

procedure verification1proc(struc){
    T1 = merge(T, verification1) // You can use this to merge two theories, i.e. T1 is the combination of theory verification1 and theory T.
    
	//Do something here: verify verification1 in the context of structure struc. 
	//At least print whether the verification is satisified or not.
}

theory verification2: Arkham{
	//Verify something here
}

procedure verification2proc(struc){
	//Do something here: verify verification2 in the context of structure struc. 
	//At least print whether the verification is satisified or not.
}

theory verification3: Arkham{
	//Verify something here
}

procedure verification3proc(struc){
	//Do something here: verify verification3 in the context of structure struc. 
	//At least print whether the verification is satisified or not.
}


procedure verification4proc(struc){
	//Do something here. 
}

theory verification5: Arkham{
	//Verify something here
}

procedure verification5proc(struc){
	//Do something here: verify verification5 in the context of structure struc. 
	//At least print whether the verification is satisified or not.
}
theory verification6: Arkham{
	//Verify something here
}

procedure verification6proc(struc){
	//Do something here: verify verification6 in the context of structure struc. 
	//At least print whether the verification is satisified or not.
}

theory verification7: Arkham{
    //Verify something here
}

procedure verification7proc(struc){
	//Do something here: verify verification7 in the context of structure struc. 
	//At least print whether the verification is satisified or not.
}

procedure allVerifications(strucToCheck){
    verification1proc(reduceVoc(Easy))
    verification1proc(reduceVoc(Unplayable))
    verification2proc(reduceVoc(Impossible))
    verification3proc(reduceVoc(Unlosable))
    verification4proc(reduceVoc(BoxedIn))
    verification5proc(reduceVoc(Easy))
    verification5proc(reduceVoc(Harder))
    verification6proc(reduceVoc(Easy))
    verification7proc(reduceVoc(Easy))
}

// Use this to map the vocabulary of the structures back to the Arkham vocabulary.
procedure reduceVoc(struc) {
    S = clone(struc)
    setvocabulary(S, Arkham)
    return S
}

// DO NOT change the includes
include "visualisation.idp"
include "TestInstances.idp"
include "Structures.idp"
include "idpd3/idpd3_voc.idp"
