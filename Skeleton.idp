LTCvocabulary Arkham { 
    // DO NOT CHANGE
    type Time isa nat
    Start : Time
    partial Next(Time) : Time
    
    type number isa nat

    type location
    type district isa location
    type building isa location

    Move_To(Time, location)
    Close_Gate(Time)
    Attack(Time)

    Location(Time) : location
    I_Location : location

    type monsternb = {0..3} isa nat
    Monsters_In(Time, location) : monsternb
    Exit_Gate(Time, building)

    Clues(Time) : number

    Open_Gate(Time, building)
    C_Open_Gate(Time, building)
    Closed_Gate(Time, building)


    Has_Connection(location, location)


    type state constructed from {player_turn, monster_turn, won, lost}
    GameState(Time) : state
    Closed_To_Win : number
    Open_To_Lose : number

    //Add your own predicates here
    
    C_Win(Time)
    C_Lose(Time)
}



theory T : Arkham {
    // investigator moves
    
    // gate stuff & gate stuff caused by investigator
    
    // monster stuff
    
    // win conditions
    {
        // Win is caused by the amount of closed gates at t + 1 being higher or equal to the amount required
        ! t [Time] : C_Win(t) <- #{ b : Closed_Gate(t, b)} + #{ : Close_Gate(t) } >= Closed_To_Win .
        // Lose is caused by the amount of open gates at t + 1 being higher or equal to the amount required
        ! t [Time] : C_Lose(t) <- #{ b : Open_Gate(t, b)} + #{ b : C_Open_Gate(t, b) } >= Open_To_Lose .
        // Lose is caused by not being able to move at player_turn
        ! t [Time] : C_Lose(t) <- GameState(t) = monster_turn & ? l : Location(t) = l & (! l2 : Has_Connection(l,l2) => Monsters_In(t,l2) >= 3).
    }
    
    // state changes
    GameState(Start) = player_turn.
    {
        // If the game is won, it stays that way.
        ! t [Time] : GameState(t + 1) = won <- GameState(t) = won.
        // If the game is lost, it stays that way.
        ! t [Time] : GameState(t + 1) = lost <- GameState(t) = lost.
        // If current turn is monster turn and not won or lost, next turn is player turn.
    	! t [Time] : GameState(t + 1) = player_turn <- GameState(t) = monster_turn & ~ C_Win(t) & ~ C_Lose(t).
        // If current turn is player turn and not won or lost, next turn is monster turn.
    	! t [Time] : GameState(t + 1) = monster_turn <- GameState(t) = player_turn & ~ C_Win(t) & ~ C_Lose(t).
        // If there is a cause to win in current turn, next turn is won.
        ! t [Time] : GameState(t + 1) = won <- C_Win(t).
        // If there is a cause to lose in current turn, next turn is lost.
        ! t [Time] : GameState(t + 1) = lost <- C_Lose(t).
    }
    
    
}

theory TimeTheo : Arkham{
    { 
        Start = MIN[:Time].
        !t : Next(t) = t + 1 <- Time(t+1). 
    }
}

procedure main() {
    show(Easy)
}


//Use this to visualise structure struc
procedure show(struc) {
    idpd3.init_idpd3();
    stdoptions.nbmodels = 1
	TH = clone(struc);
    setvocabulary(TH, Arkham);
    S = calculatedefinitions(merge(TimeTheo, T), TH)
    S = propagate(T,S)

    local model = modelexpand(T, S)[1];
    setvocabulary(model, V_out);
    local vis = merge(model, struc);
    local visModel = modelexpand(T_out, vis)[1];
	print(visModel)
    idpd3.visualise(visModel);
}


/************************************************
 *  Fill in the next part for the verifications *
 ************************************************/

theory verification1: Arkham{
	//Verify something here
}

procedure verification1proc(struc){
	//Do something here: verify verification1 in the context of structure struc. 
	//At least print whether the verification is satisified or not.
}

theory verification2: Arkham{
	//Verify something here
}

procedure verification2proc(struc){
	//Do something here: verify verification2 in the context of structure struc. 
	//At least print whether the verification is satisified or not.
}

theory verification3: Arkham{
	//Verify something here
}

procedure verification3proc(struc){
	//Do something here: verify verification3 in the context of structure struc. 
	//At least print whether the verification is satisified or not.
}


procedure verification4proc(struc){
	//Do something here. 
}

theory verification5: Arkham{
	//Verify something here
}

procedure verification5proc(struc){
	//Do something here: verify verification5 in the context of structure struc. 
	//At least print whether the verification is satisified or not.
}
theory verification6: Arkham{
	//Verify something here
}

procedure verification6proc(struc){
	//Do something here: verify verification6 in the context of structure struc. 
	//At least print whether the verification is satisified or not.
}

theory verification7: Arkham{
    //Verify something here
}

procedure verification7proc(struc){
	//Do something here: verify verification7 in the context of structure struc. 
	//At least print whether the verification is satisified or not.
}

procedure allVerifications(strucToCheck){
	verification1proc(strucToCheck)
	verification2proc(strucToCheck)
	verification3proc(strucToCheck)
    verification4proc(strucToCheck)
    verification5proc(strucToCheck)
    verification6proc(strucToCheck)
    verification7proc(strucToCheck)
}


// DO NOT change the includes
include "visualisation.idp"
include "TestInstances.idp"
include "Structures.idp"
include "idpd3/idpd3_voc.idp"
