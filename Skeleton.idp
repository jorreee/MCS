LTCvocabulary Arkham { 
    // DO NOT CHANGE
    type Time isa nat
    Start : Time
    partial Next(Time) : Time
    
    type number isa nat

    type location
    type district isa location
    type building isa location

    Move_To(Time, location)
    Close_Gate(Time)
    Attack(Time)

    Location(Time) : location
    I_Location : location

    type monsternb = {0..3} isa nat
    Monsters_In(Time, location) : monsternb
    Exit_Gate(Time, building)

    Clues(Time) : number

    Open_Gate(Time, building)
    C_Open_Gate(Time, building)
    Closed_Gate(Time, building)


    Has_Connection(location, location)


    type state constructed from {player_turn, monster_turn, won, lost}
    GameState(Time) : state
    Closed_To_Win : number
    Open_To_Lose : number

    //Add your own predicates here
    
    // At Time, monsternb monsters will move from location to district
    Monster_Move(Time, location, district) : monsternb
    
    // Causes to win or lose
    C_Win(Time)
    C_Lose(Time)
    
    // Verification
    Reachable(location, location) // true if location b is reachable from location a
}


theory T : Arkham {
    // INVESTIGATOR MOVES AND ATTACKS

    {
        // Every player turn the investigator moves from a location to an adjacent location l where there are less than 3 monsters
        Location(Start) = I_Location <- .
        ! t [Time] l [location] :  Location(t) = l <- Move_To(t,l) .    
    }
//    ! t [Time] l [location] : Move_To(Next(t),l) => Has_Connection(Location(t),l) & Monsters_In(Next(t),l) < 3 & GameState(Next(t)) = player_turn .

    // If the investigator attacks, all monsters in the location die
    ! t [Time] : Attack(t) => ? l [location] : Location(t) = l & Monsters_In(t,l) = 0 .
    // If the investigator attacks, he gains clues in t+1 equal to the monsters killed capped at 10
    {
        Clues(Start) = 0 <- .
        ! t [Time] : Clues(Next(t)) = 10 <- ? l [location] : Attack(t) & Clues(t) + Monsters_In(t-1,l) > 10 & Location(t) = l .
        ! t [Time] l [location] : Clues(Next(t)) = Clues(t) + Monsters_In(t-1,l) <- Attack(t) & Clues(t) + Monsters_In(t-1,l) > 10 & Location(t) = l .
        ! t [Time] : Clues(Next(t)) = Clues(t) <- ~Attack(t) .       
    }
    ! t [Time] : Clues(t) =< 10 .
    
    
    // GATE STUFF
    {
        // An investigator can cause a gate to close if present in a location with an open gate and at least 2 clues
        ! t [Time] : Close_Gate(t) <- ? b [building] : Location(t) = b & Open_Gate(t,b) & Clues(t) >= 2.
        // A gate is open if there was a cause for it to open in the previous turn, or if it was already open.
        ! t [Time] b [building] : Open_Gate(Next(t),b) <- C_Open_Gate(t,b) | (Open_Gate(t,b) & ~(Close_Gate(t) &  Location(t) = b)).
        // A gate is closed if the investigator closed the gate in the previous turn, or if it was already closed and there is no cause for it to open.
        ! t [Time] b [building] : Closed_Gate(Next(t),b) <- ((Close_Gate(t) &  Location(t) = b) | Closed_Gate(t,b)) & ~ C_Open_Gate(t,b).
         
    }
    // If the investigator closes a gate, he will lose 2 clues
    ! t [Time] : Close_Gate(t) => Clues(Next(t)) = Clues(t) - 2 .
    
    // If a gate is open, it is not closed.
//    ! t [Time] b [building] : Open_Gate(t,b) => ~ Closed_Gate(t,b).
    // If a gate is closed, it is not open.
//     ! t [Time] b [building] : Closed_Gate(t,b) => ~ Open_Gate(t,b).
    
    
    // An investigator can only do one action per turn
    ! t [Time] : GameState(t) = player_turn => Attack(t) | Close_Gate(t) | ~(Attack(t) & Close_Gate(t)) .
    
    
    // MONSTER STUFF
    {
        
        ! t [Time] l [location] : Monsters_In(Next(t),l) =  Monsters_In(t,l) <- ~ Exit_Gate(t,l) | Monsters_In(t,l) = 3.
        // If a monster exits a gate at time t, it will be in that building at time t + 1
    	! t [Time] b [building] : Monsters_In(Next(t),b) = Monsters_In(t,b) + 1 <- Exit_Gate(t,b) & Monsters_In(t,b) < 3.
        // There are no monsters in the beginning.
        ! t [Time] l [location] : Monsters_In(Start,l) = 0 <- .
        
        
        // Every monster turn every monster moves from a location l to an adjacent district d where there are less than 3 monsters
//        ! t [Time] l [location] : Monsters_In(Next(t),l) = sum{ d [district], amount [monsternb] : Monster_Move(t,l,d) = amount & Has_Connection(l,d) : amount} <- .
//         ! t [Time] d [district] : Monsters_In(Next(t),d) = sum{ l [location], amount [monsternb] : Monster_Move(t,l,d) = amount & Has_Connection(l,d) : amount } <- .
        
        // Every monster turn, one monster comes out of every open gate
        ! t [Time] b [building] : Exit_Gate(t,b) <- Open_Gate(t,b) & GameState(t) = monster_turn.
    }
    
    ! t [Time] l [location] d [district] : Monster_Move(t,l,d) > 0 => GameState(t) = monster_turn & Has_Connection(l,d).
    
//    ! t [Time] l [location] : Monsters_In(t,l) = sum{ d [district], amount [monsternb] : Monster_Move(t,l,d) = amount & Has_Connection(l,d) : amount}.
//    ! t [Time] d [district] : Monsters_In(t,d) = sum{ l [location], amount [monsternb] : Monster_Move(t,l,d) = amount & Has_Connection(l,d) : amount}.
    
    // If a monster exits a gate at time t, it will be in that building at time t
//    ! t [Time] b [building] : Exit_Gate(t,b) => Monsters_In(t,b) = 1.
    
    
    // WIN/LOSE CONDITIONS


    {
        
        // Win is caused by the amount of closed gates at t + 1 being higher or equal to the amount required
       ! t [Time] : C_Win(t) <- #{ b [building] : Closed_Gate(t, b)} + #{ : Close_Gate(t) } >= Closed_To_Win .
        // Lose is caused by the amount of open gates at t + 1 being higher or equal to the amount required
       ! t [Time] : C_Lose(t) <- #{ b [building] : Open_Gate(t, b)} + #{ b [building] : C_Open_Gate(t, b) } >= Open_To_Lose .
        // Lose is caused by not being able to move at player_turn
       ! t [Time] : C_Lose(t) <- GameState(t) = monster_turn & ? l : Location(t) = l & (! l2 : Has_Connection(l,l2) => Monsters_In(t,l2) >= 3).
    }
    
    // STATE CHANGES
    {
         GameState(Start) = player_turn <- .
        // If the game is won, it stays that way.
         ! t [Time] : GameState(Next(t)) = won <- GameState(t) = won | C_Win(t).
        // If the game is lost, it stays that way.
         ! t [Time] : GameState(Next(t)) = lost <- GameState(t) = lost | C_Lose(t).
        // If current turn is monster turn and not won or lost, next turn is player turn.
    	 ! t [Time] : GameState(Next(t)) = player_turn <- GameState(t) = monster_turn & ~ C_Win(t) & ~ C_Lose(t).
        // If current turn is player turn and not won or lost, next turn is monster turn.
    	 ! t [Time] : GameState(Next(t)) = monster_turn <- GameState(t) = player_turn & ~ C_Win(t) & ~ C_Lose(t).
        // If there is a cause to win in current turn, next turn is won.
        // ! t [Time] : GameState(Next(t)) = won <- C_Win(t).
        // If there is a cause to lose in current turn, next turn is lost.
        // ! t [Time] : GameState(Next(t)) = lost <- C_Lose(t).
    }
    
}

theory TimeTheo : Arkham{
    { 
        Start = MIN[:Time].
        !t : Next(t) = t + 1 <- Time(t+1). 
    }
}

procedure main() {
    show(Easy)
}


//Use this to visualise structure struc
procedure show(struc) {
    idpd3.init_idpd3();
    stdoptions.nbmodels = 1
	TH = clone(struc);
    setvocabulary(TH, Arkham);
    S = calculatedefinitions(merge(TimeTheo, T), TH)
    //S = propagate(T,S)

    local model = modelexpand(T, S)[1];
    setvocabulary(model, V_out);
    local vis = merge(model, struc);
    local visModel = modelexpand(T_out, vis)[1];
	print(visModel)
    idpd3.visualise(visModel);
}


/************************************************
 *  Fill in the next part for the verifications *
 ************************************************/

theory verification1: Arkham{
	{
        // Location l2 is reachable from location l if l2 is connected to l or there is a location l3 connected to l within reach of l2
        ! l [location] l2 [location] : Reachable(l,l2) <- (Has_Connection(l,l2) & l ~= l2) | (? l3 [location] : Has_Connection(l,l3) & Reachable(l3,l2)) .
    }
    // Every location can be reached from every other location
    ! l [location] l2 [location] : Reachable(l,l2) .
}

procedure verification1proc(struc){
    T1 = merge(T, verification1) // You can use this to merge two theories, i.e. T1 is the combination of theory verification1 and theory T.
    
	//Do something here: verify verification1 in the context of structure struc. 
    //At least print whether the verification is satisified or not.
}

theory verification2: Arkham{
	// There is no win state in this structure
    ~? t [Time] : GameState(t) = won .
}

procedure verification2proc(struc){
	//Do something here: verify verification2 in the context of structure struc. 
	//At least print whether the verification is satisified or not.
}

theory verification3: Arkham{
	// There is no lost state in this structure
    ~? t [Time] : GameState(t) = lost .
}

procedure verification3proc(struc){
	//Do something here: verify verification3 in the context of structure struc. 
	//At least print whether the verification is satisified or not.
}


procedure verification4proc(struc){
	// Test number of gameturn before lost
}

theory verification5: Arkham{
	//Verify something here
}

procedure verification5proc(struc){
	//Do something here: verify verification5 in the context of structure struc. 
	//At least print whether the verification is satisified or not.
}
theory verification6: Arkham{
    // Games remain won or lost
	! t [Time] : GameState(t) = won => (! nextT [Time] : nextT > t => GameState(nextT) = won) .
    ! t [Time] : GameState(t) = lost => (! nextT [Time] : nextT > t => GameState(nextT) = lost) .
}

procedure verification6proc(struc){
	//Do something here: verify verification6 in the context of structure struc. 
	//At least print whether the verification is satisified or not.
}

theory verification7: Arkham{
    // The investigator doesn't attack
    ! t [Time] : ~Attack(t) .
    // It is impossible to win
    ~? t [Time] : GameState(t) = won .
}

procedure verification7proc(struc){
	//Do something here: verify verification7 in the context of structure struc. 
	//At least print whether the verification is satisified or not.
}

procedure allVerifications(strucToCheck){
    verification1proc(reduceVoc(Easy))
    verification1proc(reduceVoc(Unplayable))
    verification2proc(reduceVoc(Impossible))
    verification3proc(reduceVoc(Unlosable))
    verification4proc(reduceVoc(BoxedIn))
    verification5proc(reduceVoc(Easy))
    verification5proc(reduceVoc(Harder))
    verification6proc(reduceVoc(Easy))
    verification7proc(reduceVoc(Easy))
}

// Use this to map the vocabulary of the structures back to the Arkham vocabulary.
procedure reduceVoc(struc) {
    S = clone(struc)
    setvocabulary(S, Arkham)
    return S
}

// DO NOT change the includes
include "visualisation.idp"
include "TestInstances.idp"
include "Structures.idp"
include "idpd3/idpd3_voc.idp"
